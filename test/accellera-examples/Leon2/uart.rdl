//
// Generated by Semifore, Inc. csrCompile
//   Version: 2009.01
//   Released on: Mar 18 2009 15:03:16
//   SystemRDL output
//
// Input files:
//    uart.xml
//
// Generated on: Fri Mar 20 10:58:01 2009
//           by: weber
//
//  Revision:    $Revision:$
//  Date:        $Date:$
//
//  Copyright (c) 2009 The SPIRIT Consortium.
//
//  This work forms part of a deliverable of The SPIRIT Consortium.
//
//  Use of these materials are governed by the legal terms and conditions
//  outlined in the disclaimer available from www.spiritconsortium.org.
//
//  This source file is provided on an AS IS basis.  The SPIRIT
//  Consortium disclaims any warranty express or implied including
//  any warranty of merchantability and fitness for use for a
//  particular purpose.
//
//  The user of the source file shall indemnify and hold The SPIRIT
//  Consortium and its members harmless from any damages or liability.
//  Users are requested to provide feedback to The SPIRIT Consortium
//  using either mailto:feedback@lists.spiritconsortium.org or the forms at
//  http://www.spiritconsortium.org/about/contact_us/
//
//  This file may be copied, and distributed, with or without
//  modifications; this notice must be included on any copy.
//
addrmap uart {
   reg {
      name = "data";
      desc = "Data read/write register";
      field {
         name = "data";
         desc = "Data read/write register";
         sw = rw;
         hw = r;
      } data[31:0];
   } data @0x0;
   reg {
      name = "status";
      desc = "Status register";
      field {
         desc = "Indicates that new data is available in the receiver holding register";
         sw = r;
         hw = w;
         reset = 1'h0;
      } dataReady[0:0];
      field {
         desc = "Indicates that the transmitter shift register is empty";
         sw = r;
         hw = w;
         reset = 1'h1;
      } transmitShiftRegisterEmpty[1:1];
      field {
         desc = "Indicates that the transmitter hold register is empty";
         sw = r;
         hw = w;
         reset = 1'h1;
      } transmitHoldRegisterEmpty[2:2];
      field {
         desc = "Indicates that the a BREAK has been received";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } breakReceived[3:3];
      field {
         desc = "Indicates that one or more characters was lost due to an overrun";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } overrun[4:4];
      field {
         desc = "Indicates that a parity error was detected";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } parityError[5:5];
      field {
         desc = "Indicates thata framing error was detected";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } framingError[6:6];
      field {
         desc = "Reserved";
         sw = r;
         hw = w;
      } reserved[31:7];
   } status @0x4;
   reg {
      name = "control";
      desc = "Control register";
      field {
         desc = "If set, enables receiver";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } receiverEnable[0:0];
      field {
         desc = "If set, enables transmitter";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } transmitterEnable[1:1];
      field {
         desc = "If set, enables generation of receive interrupt";
         sw = rw;
         hw = r;
      } receiverInterruptEnable[2:2];
      field {
         desc = "If set, enables generation of transmit interrupt";
         sw = rw;
         hw = r;
      } transmitterInterruptEnable[3:3];
      field {
         desc = "Selects parity polarity (0=odd parity, 1=even parity)";
         sw = rw;
         hw = r;
      } paritySelect[4:4];
      field {
         desc = "If set, enables parity generation and checking";
         sw = rw;
         hw = r;
      } parityEnable[5:5];
      field {
         desc = "If set, enables flow control using CTS/RTS";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } flowControl[6:6];
      field {
         desc = "If set, loopback mode will be enabled";
         sw = rw;
         hw = r;
      } loopBack[7:7];
      field {
         desc = "If set, the UART scaler will be clocked from EXTCLK";
         sw = rw;
         hw = r;
         reset = 1'h0;
      } externalClock[8:8];
      field {
         desc = "Reserved";
         sw = r;
         hw = w;
      } reserved[31:9];
   } control @0x8;
   reg {
      name = "scalarReload";
      desc = "Scalar Reload register";
      field {
         desc = "Scalar reload value";
         sw = rw;
         hw = r;
      } scalarReloadValue[11:0];
      field {
         desc = "Reserved";
         sw = r;
         hw = w;
      } reserved[31:12];
   } scalarReload @0xc;
};
